ifndef::imagesdir[:imagesdir: ../images]
:data-uri:

=== 安全缓存池

==== 账号登录缓存[[__SEC_CACHE_LOGIN]]

账号登录缓存是在登录之后存储到系统会话中的缓存，它通过下边代码写入到缓存中：

[source,java]
----
    ScUser.login(data)   // 登录缓存初始化（静态调用）
----

其中此处的 `data` 数据结构如：
[source,json]
----
{
    "user": "账号ID",
    "role": [
        {
            "roleId": "角色ID",
            "priority": "数值，角色优先级"
        }
    ],
    "group": [
        {
            "groupId": "用户组ID",
            "priority": "数值，用户组优先级"
        }
    ],
    "habitus": "128位会话随机字符串，每次登录时生成，等价于会话ID",
    "session": "Vert.x生成的会话 Session 的 id"
}
----

账号登录缓存的数据结构如下图：

image:zbac-logged.png[0,1024]

上述 `data` 数据输出会帮着用户初始化一个完整用户登录缓存信息，作以下几点说明：

- 用户登录缓存的主缓存池使用了SharedMap中的固定池名称 `ZERO-CACHE-HABITUS`，但实际访问（引用）它的对象为 `ScUser` 对象。
- 根据会话键 `habitus`，每个用户登录之后会分配一个唯一的 `habitus` 值，即真正开发时：您可以使用用户ID获取 `ScUser` 对象，然后直接操作 `ScUser` 对象实现用户登录数据的提取。
- 存储数据本身不包含 `habitus`，参考左侧 `remove`。
- 最核心的两个对象为 `profile` 和 `view`：
+
--
- `profile` 就是消费端提到的 64 种Profile，根据用户本身数据信息计算出来的。
- `view` 则是一个动态结构，会根据用户发送请求计算 `viewKey`，最终根据这个值计算用户的视图信息，视图信息是序列化过后的 `DataBound` 对象。
--

==== 401认证缓存[[__SEC_CACHE_AUTHENTICATE]]

认证缓存在系统中由核心框架提供 *执行模式*，开发人员则只需要提供存储数据结构即可，有了认证缓存后，用户就不需要每次发送请求都让系统运行 *标准认证流程*，只有当如下情况发生时才会要求用户重新认证：

- 用户令牌过期，需要使用新令牌对用户重新执行认证。
- 系统检测到用户出现了非安全性操作。
- 用户账号出现了异常，导致请求过程中安全身份信息无法通过会话检查。

*401认证缓存* 使用了SharedMap中固定的池名称 `ZERO-CACHE-401`，它的数据结构如下：

image:zbac-pool-401.png[0,900]

从上边讲解可知，401认证缓存中实际存储的就是 JWT 令牌中的基本信息（去掉了角色和组部分的数据）

==== 403授权缓存[[__SEC_CACHE_AUTHORIZATION]]

授权缓存在核心框架层只提供了接口，并未提供实现，而Zero Extension框架中提供了本章的实现。有了授权缓存后，用户就不需要每次发送请求申请资源数据时运行 *扩展授权流程*。

*403授权缓存* 使用了SharedMap中固定的池名称 `ZERO-CACHE-403`，它的数据结构如下：

image:zbac-pool-403.png[0,900]

[CAUTION]
====
从数据结构上看，授权缓存的结构相对简单，`habitus` 可标识用户登录的当前会话ID，而每个资源都会包含 `TRUE` - 有权限，`FALSE` - 无权限二选一的值，正如在安全管理中讲到的，实际表示：*用户是否有权限访问该资源*。注意此处提到的是否可访问只牵涉最基础的授权，并不包含安全视图相关信息，安全视图解决的是 *用户访问多少* 的问题。
====

==== 资源缓存[[__SEC_CACHE_RESOURCE]]

Zero框架中定义的资源一般情况不会被高频修改（除非走开发中心资源定义），所以资源信息在第一次请求读取之后就被初始化放到了资源缓存中，资源缓存和 `habitus` 无关，它是所有角色和用户可共享的数据结构，这也符合RBAC模型的定义。

*资源缓存（又称为资源池）* 使用了SharedMap中可配置的池名称，默认 `POOL_RESOURCES`，资源池的结构如下：

image:zbac-res.png[0,900]

资源池的结构很简单，只有一点需说明就是此处为什么不是直接存储权限集，而要隔离一层Profile信息放在中间，主要原因是后续拓展资源执行多Profile模型时，资源池的概念会被抽象，一旦抽象之后资源池的内容就不再是只读模式，有可能会在运行过程出现调整，多个Profile并行访问资源池以及一个资源提供多种Profile的模型（比如打开组）。

==== 权限缓存

Zero框架中权限缓存是最简单的缓存，*权限缓存* 使用了SharedMap中可配置的池名称，默认 `POOL_PERMISSIONS`，权限缓存结构如下：

image:zbac-pool-perm.png[0,900]

