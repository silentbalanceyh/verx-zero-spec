ifndef::imagesdir[:imagesdir: ../images]
:data-uri:
:table-caption!:

=== 「B/2」第二模型（父从表）

按照整体结构，父主表要求 `D_DOC` 表作为 `NM_LAW` 表的从表，二者执行 `JOIN`，二表最终形成的 `SQL` 语句应如：

[source,sql]
----
SELECT * FROM `NM_LAW` AS T1 JOIN `D_DOC` AS T2 ON ( T1.`DOC_ID` = T2.`KEY` )
/*
 * 主模型：nm.law
 *           - doc_id
 * 从模型：d.doc（OOB中模型）        
 *           - key
 */ 
----

==== 连接模式

连接模式定义于枚举变量 `io.modello.eon.em.EmModel.Join` 中，三种模型对应不同的使用场景。

===== `CRUD`

`zero-crud` 中会有静态缓存，系统会生成两个缓存用来存储 `KModule` 的配置表，此配置表目前存储于 Memory 内存中，后期可以修改存储放到 **配置服务器** 中来存储模型定义。

- 主缓存：`identifier = KModule` 的缓存，存储的和模型标识符绑定的真实的模型配置。
- 辅助缓存：`alias = identifier` 的缓存，存储了从 **别名** 到 `identifier` 的引用表，您可以通过传入任何合法的别名找到对应的模型定义。

由于 `alias` 不可以重复，而 `identifier` 是可以重复的（哈希表），所以一个 `identifier` 有可能包含超过 **两个** 以上的别名，后期只要管理存储就可以针对模型进行定位了。CRUD这种模式查找模型时，就是使用 `JOIN` 部分去查找对应的 `KModule`，它的连接模式如下图：

image:exp-app-join.jpg[,800]

从图上总结几点：

1. `IxMod` 为请求过程中的模型容器，这个模型容器一般会包含两个核心模型引用变量，实例本身每次请求都会创建：
+
--
- `module`：当前模型主模型，类型为 `KModule`。
- `connect`：连接模型，类型为 `KModule`，系统会根据 `KJoin` 中的连接点配置计算连接模型（并且会同时抓取 **父主表** 和 **父从表** 模式）。
--

2. 主模型的 `connect` 和 从模型的 `module` 实际在底层是同一个缓存模型，引用一致，所以 `IxMod` 本身创建的成本并不高，并且支持 **递归引用** 模式，且不会出现模型重复定义的情况。
3. 模型池只有 `zero-crud` 中存在，即连接模式是 `CRUD` 的模式时才会生效，若是其他 **连接** 模式此处是不生效的。


目前 `IxMod` 这种模型容器只能支持 **双连接** 的方式，简单说 **父主表** 和 **父从表** 两种模式只支持一种，且只能是两个模型 `module / connect` 相连接，不支持 **两个以上** 的模型连接。对比下这种建模方式和 `Hybrid` 的区别：

[options="header"]
|====
|特性对比|`CRUD` | `Hybrid`
|模型数量|最多 **2** 模型|超过 **2** 个模型
|使用场景|标准化 CRUD 管理|现阶段版本主要用于工单模型
|对接 `HAtom`|不对接|可对接 `HAtom` 实现所有建模层的功能
|====

实际上 CRUD 模型在管理模块开发中扩展性够好了，通常标准化管理中不推荐使用 `JOIN`，但由于业务复杂度，Zero 支持的建模方式大部分依赖 `JOIN`，但是考虑到通用性和高频使用性，一般不推荐使用超过三张表做管理（两次 `JOIN`），考虑点如下：

- 单次 `JOIN` 是允许的，父子表结构：
+
--
- 一张表负责标准化、抽象、共享属性、去冗余。
- 一张表负责具象化、业务语义。
--

- 不推荐两次 `JOIN` 的原因在于：一方面是系统的性能开销会打折扣，另外一方面三张表可能造成表和表职责不清晰，这和 `OO` 中继承的使用类似，尽可能控制在 **抽象和具象** 两层，超越层次之后考虑 **重构**。

[WARNING]
====
从目前的很多场景看起来，**双表 JOIN** 的模式已经能够覆盖最少 `90%` 的企业管理业务型场景了，Zero 上运行了接近 `20` 个案例，真正使用了这种模式的也只有 `20%` 的项目，所以真正可以解决问题的是采用**系统设计**的手段，也就是上述提到的**重构**的方式来解决。从**程序设计**上解决数据结构、模型结构不合理的地方本来就是在交付项目中值得深思的一个问题，若一个项目要想长久维护很多细节考虑点只能从**课本**和**经验**双管齐下的方式来考虑，最终的解决方案是从设计层面去考虑，更抽象更通用，落到实际业务中才具备相当好的扩展性。
====

==== 配置部分

====
由于 **父从表** 并非是成熟模块，所以目前放出来的配置都是开发过程中的配置，文档结束时会逐渐完善。
====

由于此处是父从表，先看看父模型 `d.doc` 的配置：

[source,json]
----
{
    "name": "doc",
    "daoCls": "cn.vertxup.doc.domain.tables.daos.DDocDao",
    "field": {
        "unique": [
            [
                "name",
                "sigma",
                "version"
            ]
        ]
    }
}
----

再看看子模型 `nm.law` 的配置：

[source,json]
----
{
    "name": "nm-law",
    "daoCls": "com.zhaowing.norm.domain.tables.daos.NmLawDao",
    "field": {
        "unique": [
            [
                "issuedSn",
                "sigma"
            ]
        ],
        "numbers": {
            "code": "NUM.DOC.LAW"
        },
        "attachment": [
            {
                "field": "files",
                "condition": {
                    "modelId": "nm.law"
                }
            }
        ]
    },
    "connect": {
        "reference": {
            "crud": "d.doc",
            "keyJoin": "key"
        },
        "source": {
            "keyJoin": "docId"
        }
    }
}
----

==== 请求原理

最前边已经提供过 **父从表** 模型的图了，**父从表** 模型的请求原理如下：

image:zact-mode-branch.png[,960]

结合上述请求原理图

1. 通常在 Zero Extension 中保留的都是比较纯的 **模型定义**，存在 `JOIN` 时您需要在 **启动器** 中追加配置覆盖默认值。
2. **父主表** 和 **父从表** 的配置段有些区别，典型区别在于：
+
--
- 父主表依赖参数 `module` 来判断当前接口操作的子模型信息，属于 **动态筛选** 的模式，所以一个 `target` 包含了不同的子模型定义。
- 父从表模型不存在选模型的情况，直接从子模型出发，属于 **静态筛选** 的模式，所以一个 `reference` 就指定了夫模型。
--
3. 一般是请求入口走哪个模型，那么扩展的 `connect` 就位于哪个模型，如 **父从表** 模型请求入口在子模型 `nw.law` 上，所以此处 `connect` 配置也在子模型上。

====
**父从表** 模型比 **父主表** 模型相对简单，主要是不依赖任何前端 `module` 的参数来做 **动态筛选** 流程，且和子模型绑定的父模型本身就是唯一的。
====