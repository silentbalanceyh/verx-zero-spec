ifndef::imagesdir[:imagesdir: ../images]
:data-uri:

=== 详解上传

本章详细解析**集成上传**部分的原理以及实战教程，其目的是帮助开发人员实现快速**调试**文档上传/下载功能，解决如下问题：

1. 为什么我的目录没有创建出来？
2. 为什么我的附件没有拷贝到目标集成目录中？
3. 为什么我的附件更新没有成功？

[TIP]
====
上述问题是文档管理、上传、下载中最常见的几个问题，若开发人员不了解，那么和**上传/下载**相关的功能就会运行不正常，不如预期，所以本章节的主要目的就是帮助开发人员了解调试并解决相关问题，部分配置在**前端/后端**开发中都有说明，虽然教程部分略有重复，但侧重点和视角不同，开发人员可从不同的场景了解此部分原理。
====

==== 上传流程

Zero Extension中的上传流程如下图（细节到接口）：

image:zis-config.png[0,960]

1. 从图上可以看到，整个上传部分执行了**两次**请求，第一次请求会将文件上传到临时文件夹中 `/file-uploads/` 中，参考如下：
+
--
image:zis-file-upload.png[,600]

[CAUTION]
====
如果在您的应用中不启用 `zero-is`，那么上传的文件就会直接放在 `/file-uploads/` 目录下，`FileAction` 中会检查和拦截是否带有**集成配置**，若带有集成配置才会走入流程中的 `SPI` 接口，若没有集成配置则到此为止。这种模式是 `Vert.x` 的原生格式，在**原始框架**中直接上传就是这个效果，这也是 `Vert.x` 中的一个小问题，就是技术层面已经实现了功能，但业务层面若要使用无法对接企业的相关服务，所以这部分必须要执行定制，这也是设计 `zero-is` 集成服务的原因。

不仅如此，此步骤不会访问后台数据库，只是单纯将 `Vert.x` 中生成的上传的配置数据以 JSON 的方式返回给前端，不这样做的目的在于用户点击**上传**之后可能不点保存而终止了工单或记录的提交，为了不在附件表中产生数据冗余，真正访问数据库（ `X_ATTACHMENT` ）的操作是在**提交**流程中完成的。
====
--
2. 第二次发请求时候会在 `zero-crud` 模块中调用 SPI 接口去执行**附件处理**和**目录处理**：
+
--
- **目录处理**：负责根据您启用 `zero-is` 之后的存储规划将新目录初始化创建出来，此过程访问的是**抽象存储**接口，无关底层协议，底层使用什么协议取决于和 `I_DIRECTORY` 绑定的集成配置 `I_INTEGRATION` 记录。
- **附件处理**：将 `/file-uploads/` 中的临时文件拷贝到存储规划对应的目录中形成可以人工阅读（离线访问）的文件管理，此文件管理也可以直接从**文档管理**进入。
--
3. 每一条目录记录（ `I_DIRECTORY` ）都关联了**集成配置**和**Fs组件**：
+
--
- **Fs组件**：提供了操作系统级别的 `io` 接口，可针对目录执行增删改等各种操作，`zero-is` 实现了两个。
- **集成配置**：若启用了 `FTP, SSH, NFS` 等存储时，集成配置负责提供对接的协议端的配置协议而实现更加细粒度的存储行为——如此每个目录都可以独立一套集成配置形成异构存储模式。
--

==== 配置部分

===== 前端配置

Zero Extension中的三个主要上传下载组件如：

[options="header", cols="2,2,6"]
|====
|组件名|配置函数|含义
|`FileLogo`| `aiFileLogo`|图片、Logo上传专用组件，只能上传图片并提供预览功能。
|`FileBatch`| `aiFileBatch`|批量文档上传，多用于流程部分的附件处理，通常可支持多个文件上传（卡片呈现、列表呈现）。
|`FileUpload`| `aiFileUpload`|单文档上传，如法规、制度管理，文档审批流，这种模式只能上传一个独立文件。
|====

参考下边**法规管理**的基础上传配置：

[source,json]
----
{
    "metadata": "files,法规文档,16,,aiFileUpload,text=上传",
    "optionJsx.accept": "*/*",
    "optionJsx.config.limit": 10240,
    "optionJsx.ajax.uri": "/api/file/upload/:identifier?category=:category&directory=:directory",
    "optionJsx.ajax.download": "/api/file/download/:key",
    "optionJsx.ajax.params": {
        "identifier": "FIX:nm.law",
        "category": "FIX:DOC.NORM.LAW",
        "directory": "/合规文档/法规库",
        "formula": "/${code}"
    },
    "optionJsx.config": {
        "linker": {
            "fileKey": "fileKey",
            "name": "name",
            "fileName": "fileName"
        }
    },
    "optionConfig.rules": [
        "required,上传法规文档不可为空，请上传您的法规文档！"
    ]
}
----

配置解读：

1. 此处的 `uri` 有几点必须说明：
+
--
- identifier参数是必须参数，存在于请求路径上，任何时候都不会**缺席**。
- category参数一般都会带，可能是一个固定值，也可能是一个根据当前表单配置的值，属于**维度**参数，可在管理过程中对附件进行分类。
- directory参数：这个参数是一个很重要的参数，带了这个参数之后才意味着您后端启用了 `zero-is`，本次上传会根据参数信息访问规划的存储。
--
2. 关于 `params` 的配置：
+
--
此处 `optionJsx.ajax.params` 的配置启用了输入解析器，其实表单中的这部分片段可以配置成如下：
[source,json]
----
{
    "...": "...",
    "optionJsx.ajax.uri": "/api/file/upload/nm.law?category=DOC.NORM.LAW&directory=:directory",
    "optionJsx.ajax.download": "/api/file/download/:key",
    "optionJsx.ajax.params": {
        "directory": "/合规文档/法规库",
        "formula": "/${code}"
    }
}
----
上述配置的坏处就是若法规（`nm.law`）模块要**坐地扩展**，您就不得不更改两个参数的来源，而示例中的模式则只需要改 `FIX` 部分的输入表达式即可。
--
3. 关于 `directory` 的解析：
+
--
directory解析分成两种模式：

- 固定不解析：这种模式下不启用 `formula` 的表达式，那么上传的所有文件在同一个目录中（如公告管理），由于不带单号无法分单据管理。
- 动态目录：这种模式下后端会先生成目录，再将文件转存到目录中，目录本身带有单号信息或其他规则，十分方便做工单附件或记录附件管理。
--

关于 `linker` 配置就没有什么值得详细讲解的地方了，此配置对 `FileBatch` 不生效（思考逻辑就明白了）。

===== 后端配置

后端配置的目录规划部分此处不说明，参考：link:#__ACTION_IS_STORE[存储规划] 中的讲解，但是 `crud` 模块中模型配置是需要修订的（ `FileAction` 依靠此配置判断是否继续访问存储）。

[source,json]
----
{
    "...": "...",
    "field": {
        "...": "...",
        "attachment": [
            {
                "field": "files",
                "condition": {
                    "modelId": "nm.law"
                }
            }
        ]
    }
}
----

上述配置是 `zero-crud` 中专用的模型配置，此处配置需在 `field` 中追加附件配置节点 `attachment`，您可以追加多个附件属性，而此处的 `modelId` 等价于前端配置的 `nm.law`，其实后端配置本身也是支持 JEXL 的表达式的，简单说此处的 `modelId` 可以支持类似 `$` 的运算符实现**动态化**，补充规则后您就可以根据实际所需来完成附件的定制。

====
附件最终是存储在 `zero-ambient` 中的附件表 `X_ATTACHMENT` 里的。
====

==== 调试技巧

最后介绍一下附件本身的调试技巧（流程上的几个关键点）。

===== 集成检查点

[options="header",cols="2,2,6"]
|====
|模块|类名|包名
|`zero-crud`| `FileAction`| `io.vertx.mod.crud.uca.input.file`
|====

image:zis-debug-config.png[,800]

上传过程中断点如截图处，完整流程如下：

1. 每个操作先检查 `IxMod` 中的字段配置是否包含了 `attachment` 节点，若包含则证明模型带了**文件流程**。
2. 执行文件流程时先按属性名对所有附件配置进行条件筛选，然后执行子类传入的方法，此方法签名为 `(JsonObject, JsonArray) -> JsonArray`。
3. 子类会触发附件相关操作：
+
--
[options="header",cols="3,7"]
|====
|类名|含义
|`FileFetchPre` |附件查询
|`FileUploadPre` |附件上传
|`FileSavePre` |附件更新
|`FileRemovePre` |附件删除
|====
--

`FileAction` 是一个**包域**的抽象类，只适合框架内部扩展实现附件配置检查，主要目的是为了检查当前**模型**中是否带有 `attachment` 的附件属性再执行子类提供的相关方法。

[WARNING]
====
包域是Java开发人员经常忽略的一个域，其实在代码设计中是很好使用的一个功能。有人说，即使设计了**包域**，您不想要包外访问，但从同一个包中继承的内容依旧是可以访问的，依旧可以破坏所谓的**封装**，真如此？相反，**包域**是君子协议，假设您自己的设计中是有系统架构存在的，简单说，同名包本身就带有**名空间**的基本概念，限定您的类必须和**包域**内容在同一个包中才可以访问对方，这实际是一个可进可退的设计。默认场景下，您的IDE是不会把包内的东西开放出来让您使用 `new` 或 `.` 的方式去访问，那么您的开发本身会变得很干净；扩展场景下，您可以创建一个包内同名包的**功能类**将内容开放出去（破坏封装），但这种方式并非破坏，而是**扩展**（若真心想破坏系统，在代码这个级别是拦不住的，反向工程流行的年代，防君子不防小人）。
====

===== 附件操作点

上述 `FileAction` 的子类在执行过程中，调用了 SPI 接口 `Attachment` 中的方法来执行真正的**代码逻辑**，所以根据您想要调试的功能（上传、更新、删除、查询），您可以将断点打在实现类对应的方法上。

[options="header", cols="2,2,6"]
|====
|模块|类名|包名
|`zero-ambient` | `ExAttachment` | `io.horizon.spi.feature`
|====

image:zis-debug-action.png[,800]

比如以**上传为例**，断点如截图处，完整流程如下：

1. 先检查输入是否为空，若没有任何输入，直接返回结果。
2. 调用 `At.fileDir` 做**目录处理**初始化流程，此处会检查目录执行目录规划。
3. 再执行 `X_ATTACHMENT` 表的数据更改操作。
4. 最后再执行 `At.fileUpload` 将操作附件拷贝到规划好的文件目录中，做**文档处理**。

[TIP]
====
Zero在执行流程中很少使用到**事务**，并非**事务**不重要，而是采取了幂等操作的高要求，再在特定的场景中开启数据库事务，分布式模式下纯事务的模型并非是一个高效的模型，如传统的 `JTS/JTA`，告别了曾经 JavaEE 中的分布式事务之后，您需要在操作行为中执行更多的操作来作保证。其中集中如下幂等性相关点：

- 操作幂等性：单纯的某一个操作执行一次、执行N次，最终效果是一致的，这种幂等性的解决方案是采用更加巧妙的设计去完成。
- 步骤幂等性：针对单个方法中的某个步骤而言，执行部分、执行完成，最终效果是一致的，这种幂等性的解决方法可以采用分布式模式下的补偿算法。

上述两层幂等性的设计可以用于单机系统，也可以用于分布式场景，比单纯的数据库级别的事务更具实用性，这也是Zero默认场景下不支持事务的原因，后续更有可能是往分布式事务算法层面走而忽略单点下的数据库事务。
====

===== 目录规划点

SPI 实现类 `ExAttachment` 执行过程中，调用了两个静态类的方法，分别对应**目录**和**文件**，目录规划点如：

[options="header",cols="2,2,6"]
|====
|模块|类名|包名
|`zero-ambient`| `AtFsDir`| `io.vertx.mod.ambient.refine`
|====

image:zis-debug-atdir.png[,800]

**上传**为例，断点如截图处，完整流程如下：

1. 提取 `directory` 目录参数，然后调用 SPI 集成接口 `ExIo` 执行底层的 `io` 操作。
2. 第二个断点是在执行完 `io.dirTree` 之后的回调部分，断点走到这里目录规划已经完成了，若有规划目录存在则直接执行目录内的操作，若没有相关规划则跳过步骤。
3. 后续所有步骤都是在为 `X_ATTACHMENT` 做相关数据准备，它的下一个步骤会执行**文件操作**。

===== 特殊动态目录

文件在执行**增、删、改**的过程中，若启用了 `zero-is` 的集成服务，会多一个特殊操作：**目录同步**。举个例子，您的文档是传到 `/合规文档/法规库/` 目录下的，但是由于配置中带有 `${code}` 类似的表达式执行动态目录创建，所以文件最终会写入 `/合规文档/法规库/${code}/` 的目录下形成**动态目录**，此时 `${code}` 关联的目录是动态生成，所以**目录同步**会根据您所管理的实际存储地址执行**同步**操作，此处会带有一定的智能计算。

[options="header",cols="2,2,6"]
|====
|模块|类名|包名
|`zero-ambient`| `AtFsDir`| `io.vertx.mod.ambient.refine`
|`zero-is`| `IsDir`| `io.vertx.mod.is.refine`
|====

image:zis-debug-verify.png[0,800]

**上传**为例，断点如截图处，完整流程如下：

1. 此处的 `params` 中包含了 `storePath` 属性，此属性是一个 `[]` 类型，假设有 `/合规文档/法规库/${code}`，这种场景下此值为：
+
--
[source,json]
----
[
    "/合规文档",
    "/合规文档/法规库",
    "/合规文档/法规库/XXXX"
]
----

假设此处 `${code}` 的值为 `XXXX`，上述结构为存储路径的完整结构。
--
2. 系统会扫描此处的所有目录在数据库中是否存在（ `I_DIRECTORY` 是否有记录 ），若有记录则同步，若无记录则新增，**新增**时和该目录有关系的 `I_INTEGRATION` 直接从父目录继承（包括 `Local, FTP, SSH` 等。
3. 系统初始化好所有配置数据之后，会检查目录路径中是否真实存在此文件，然后**覆盖**（这就是为什么上传最好不重名的原因）。

[TIP]
====
此操作目前仅用于**动态目录**，只有动态目录执行过程中环境里会出现：_根据输入数据构造的路径_，其他模式如**普通上传**或**静态上传**的模式都不会导致这种情况发生——输入数据不会影响目录构造，所以这种特殊操作也只有在**动态目录**功能中会出现。

这里多谈一点：为什么需要动态目录？在企业管理（非网站或应用）中，**离线**读取目录是一个非常重要的功能，若您的系统无法访问进行**目录下载**，那么部分审批工单或执行工单最好的方式就是走线下流程，而此时依赖的资料在系统中无法拿到，这种模式下有一种折中的办法（破坏管理权限）就是直接登录到存储的服务器中去找到对应文件，那么查找的依据就是工单号和文件名：

1. 这种模式是不得已而为之，开发人员心里应该清楚这是非法的行为。
2. 但企业的IT基础设施不可能绝对完美，这是让一个系统趋近于**完美**的柔性问题，当中小型企业资源无法一次性准备充分时，这种模式是一种现实选择。
3. 这种模式会暴露出企业在管理、制度和工具层的短板，当它消除时，企业的成熟度就自然提高了。

所以**动态目录**是从管理角度非常重要的一个问题，让管理和工具做适当的解耦，而不是依赖工具，制度、流程、标准、工具四者是并驾齐驱的马车，帮助企业提升数字化进程，四者相互之间是制约和协同的关系，千万不能产生任何依赖。
====

===== 文档处理点

SPI 实现类 `ExAttachment` 执行过程中，调用的第二个静态类的方法，文档处理点如：

[options="header",cols="2,2,6"]
|====
|模块|类名|包名
|`zero-ambient`| `AtFs`| `io.vertx.mod.ambient.refine`
|====

image:zis-debug-atfs.png[,800]

**上传**为例，断点如截图处，完整流程如下：

1. 检查输入的附件是否有值，若无值直接返回。
2. 调用内部 `splitInternal` 做分流处理，分流过程中会根据附件是否关联目录（ `directoryId` 属性 ）执行不同的附件流程：
+
--
- 若无目录关联（ `Local` ）：不执行相关流程，直接跳过，这种模式下会维持 `Vert.x` 中默认的上传结构。
- 若关联目录（ `Remote` ）：执行远程处理流程，此处会调用 SPI 接口 `ExIo` 执行底层的 `io` 操作。

====
此处有了**分流器**之后，您可以让不同的文件存储到不同的地址下，而且单文件可以按目录执行操作。例如：此处接口推送了 100 个文件，分别存放于 `7` 个目录中，这种场景下调用底层的行为会规约成 `7` 个而不是按文件数量来执行底层命令。
====
--
3. 调用内部 `splitRun` 做默认值设置处理，默认值设置处理也是执行的分流器，若 `Remote` 失败，则直接返回到 `Local` 中执行，实现默认文档处理行为。

此处两个内部的断点 `splitInternal / splitRun` 就不截图了，您可以自行探索这两个点的位置。

===== 底层执行点

底层执行点也是一个 `ExIo` 的 SPI 接口，它的实现类如下（包含了目录和文档操作，此处不提供断点截图）：

[options="header",cols="2,2,6"]
|====
|模块|类名|包名
|`zero-is`| `ExPath`| `io.horizon.spi.business`
|====

**上传**为例，完整流程如下：

1. 内部访问 `io.vertx.mod.is.uca.command.Fs` 接口的实现类，此实现类从 `I_INTEGRATION` 表中提取。
2. `Fs` 的实现类调用了高阶接口 `HFS`，直连高阶规划底层分布式文件接口，配合 `zero-is` 完成目录集成功能。

`Fs` 接口的实现类如下：

[options="header",cols="4,6"]
|====
|类名|含义
|`io.vertx.mod.is.uca.command.FsDefault` |服务器上操作系统对应的 Io 底层操作。
|`io.vertx.mod.is.uca.command.FsReadOnly` |服务器上操作系统对应的 Io 底层操作（只读模式，屏蔽了写操作）。
|====

[TIP]
====
参考最早的流程图，以及几个核心的调试检查点，您就可以直接针对上传处理进行监控并解决最早抛出的三个问题了，这也是现阶段Zero框架中完整的**目录/文件**处理流程，教程中已经将所有的核心点都讲解了，开发人员可仔细阅读并根据源代码理解内部处理原理。
====