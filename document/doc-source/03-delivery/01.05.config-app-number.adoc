ifndef::imagesdir[:imagesdir: ../images]
:data-uri:

=== 序号规则[[__CONFIG_X_NUMBER]]

Zero中为了满足业务需求，提供了 *序号定义规则* 模块，可以根据您想要的业务规则生成不同的序号。

==== 规则存储

序号规则主要存储在 `X_NUMBER` 表中，该表定义了序号的基本生成规则，您可以为不同的模型定义序号生成信息，先看看表结构：

[options="header",cols="12,12,12,64"]
|====
|属性|字段|表达式|含义
|code| `CODE` ||提取序号规则的唯一编码，通常在配置序号规则时会使用该系统内码从数据库中提取序号生成规则。
|current| `CURRENT` | `${seed}` |编号当前值，自增长/递减时专用，current + step 的基础规则执行增长，current - step 的基础规则减小。
|format| `FORMAT` ||格式信息，用于定义最终编号格式，组合所有表达式。
|identifier| `IDENTIFIER` ||编号对应的模型统一标识符，最终会关联到模型中，原则上：某个应用中某个模型的 `code` 必须具有唯一性，但不同模型的编号规则可重复，由于现阶段很多地方直接使用了 `code` ，所以此属性只是保留作为模型中编号规则提取时使用。
|prefix| `PREFIX` | `${prefix}` |编号前缀，如事件：`IM` 前缀，问题：`P` 前缀，任务 `T` 前缀。
|suffix| `SUFFIX` | `${suffix}` |编号后缀，追加到最终序号的最后边。
|time| `TIME` | `${time}` |时间Pattern定义，如您可使用 `YYYY-MM-DD` 的方式在编号中加上时间戳，此属性会设置最终格式化后的时间，并借用表达式存储在基础编号规则中。
|length| `LENGTH` ||编号长度，用于制定编号的最终长度，但此长度不包含前缀 prefix 和 后缀 suffix 部分。
|step| `STEP` ||步进系数，编号每次按 `step` 进行变化。
|decrement| `DECREMENT`||递增/递减？控制编号的生成方向。
|renewal|`RENEWAL`||编号生成完成后是否刷新（是否循环），循环编号一般在带有时间戳的模式中使用，固定编号若采用循环会导致编号重复。
|====

==== 隐式规则

- 当前序号生成过程中没有 *填充规则*，如果长度不够，会使用右值零填充来构造 `${seed}`，如长度为 8，`current` 为：`14537` 编号，最终生成的 `${seed}` 为：`00014537`。
- 序号的最终生成依赖 `format` 定义，通常我们会在该格式中使用类似 " ``${prefix}${time}${seed}`` " 的格式，这样的格式可以帮助您生成最终编号。
- `${prefix}` 和 `${suffix}` 没有严格意义上的前后缀的做法，语义上使用的是前后缀，但实际生成过程中还是依赖 `format` 中的定义。

==== 发号器

现阶段编号规则只是一个简易的发号器，该发号器会有如下缺点：

1. 生产部署时为了防止重复，需启动 `NumberAdjust` 应急程序对编号执行修正，不修正的模式下会导致新生成的编号和旧编号重复。
2. 这种模式依赖数据库中的自增长机制，这个机制是同步的，如果同时生成多个编号时会产生编号锁导致效率低下，虽然Zero内部已经提供了批量生成算法生成相关序号，但如果是大规模应用此处还是会遇到这种情况。
3. 编号理论上还是需要存储相关业务信息，并带有 *排序* 性质，后期可以考虑扩展此功能开发通用 *发号器* 功能。