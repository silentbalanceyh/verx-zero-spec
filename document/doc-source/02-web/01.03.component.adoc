ifndef::imagesdir[:imagesdir: ../images]
:data-uri:

=== 常用组件

==== 日志器

日志器在 Zero Extension 会将部分 **彩色日志** 打印在浏览器的开发工具 `console` 中，常使用的 **骨架代码** 如：

[source,js]
----
    return Ex.yoRender(this, () => {
            // ....
    }, Ex.parserOfColor("PxRBACGroup").page());
----

您可以调用 `Ex.parserOfColor` 方法构造 **日志器生成器** 对象，之后调用对应的方法实现日志器的选择，上述骨架代码中使用了 `page` 类型的日志器。

[options="header",cols="2,8"]
|====
|可用日志器|使用场景
|`internal`|内部自定义
|`private`|私有组件
|`form`|表单组件
|`list`|列表组件
|`action`|列表四个区域专用
|`tpl`|模板页
|`component`|公有组件
|`container`|容器专用，对应 `src/container`
|`page`|页面组件，对应 `src/components`
|`type`|带有 `:type` 类型参数的维度页面
|`control`|自定义组件
|`dynamic`|动态配置页
|`view`|视图组件（仅查看，包括报表页）
|`define`|用户自定义页面，对应 `src/app`
|`toolkit`|（开发中心）工具开发专用
|`normalize`|（开发中心）标准化专用
|====

====
上述 **日志器** 并不存在严格规定，只是一种约定，根据目前开发过的所有项目的一个不成文的软文，您也可以根据自身情况选择不同的 **日志器** 来辅助开发 或自定义更多日志器帮助开发人员监控开发过程中的所有日志。

*彩色日志* 是 Zero UI 中的其中一个亮点，主要目的是辅助开发人员在前端更加顺利完成数据定位和程序调试。
====

==== Assist 辅助数据

Assist 在整个 Zero Extension 中已经成为了一种概念：辅助数据，又或者称为关联数据，一般用来描述主要管理模块中与之相关的其他表中的数据，让主模型的属性变成可管理型的模块数据。常用的辅助数据加载配置如下：

- `_assist`：这种节点通常位于当前某个页面的 `UI.json` 配置文件中，一旦使用 `@Ux.zero` 加载过资源文件之后可直接在 `componentDidMount` 中调用对应的API加载，最终更新到状态中。
- `xxx.assist`：这种节点一般位于组件内部，如 `_form.assist` 属于表单内部的辅助数据。

Zero Extension中有三种常见的辅助数据（ Assist / Datum 语义）：

[options="header",cols="3,7"]
|====
|辅助数据类型|含义
|`TABULAR`|列表类辅助数据，主要访问 `X_TABULAR`（本章开发）形成不带 **树型结构** 的辅助数据。
|`CATEGORY`|分类辅助数据，主要访问 `X_CATEGORY` 形成带 **树型结构** 的辅助数据。
|`ASSIST`|带有Ajax配置和定义的辅助数据，可以访问任何一张系统中的表，通常依赖您开放出来的接口，此接口不可通用，所以用户可定制。
|====

===== 定义和消费

Assist 数据的基本规范如下

1. 所有的字典都会有一个名字，在 Zero 框架中使用单词 `DATUM` 来描述，这个名字通常格式是 ：`prefix.name`：
2. 此处 `prefix` 表示当前字典数据的前缀，而 `name` 则是字典本身的相关信息，一般同一类型的字典拥有相同的 `prefix`，需注意的是当前页面定义的 **辅助数据** 的名称必须是唯一的。
3. 在消费绑定时候，字典的名称会直接使用 `source=prefix.name` 的方式进行 **辅助数据** 绑定以及消费。
4. 辅助数据和字典数据在 `React` 组件中一般会存在于 props 或 state 中，每个字典的命名规则使用 `$a_prefix_name` 或 `$t_prefix_name`，为了开发人员简化处理，所有 API 中的传入参数依旧使用 `prefix.name`（您不用去关心组件中变量使用的是什么，仅需要在调试时知道如何识别即可）。

参考如下定义：

[source,json]
----
{
    "_assist": {
        "ajax.groups": {
            "uri": "/api/group/by/sigma"
        },
        "ajax.groups.type": {
            "uri": "/api/type/tabulars/:type",
            "magic": {
                "type": "FIX:zero.group.type"
            }
        }
    }
}
----

从定义可以知道此处的 `Assist` 辅助数据的数据结构和 Ajax 定义很近似，都包含了 `uri, method` 等和远程通信相关的基础配置，包括参数中支持 **输入解析器** 的配置格式。上述示例中定义的字典如：

[options="header",cols="2,3,5"]
|====
|字典名字|消费配置|含义
|`ajax.groups`|`source=ajax.groups,value=key,label=name`|从远程 RBAC 模块中的读取 `S_GROUP` 表中的数据构造组列表信息。
|`ajax.groups.type`|`source=ajax.groups.type,value=code,label=name`|从远程全局字典配置中读取 `X_TABULAR` 中的 **组类型** 中的
|====

加载 Assist 辅助数据的骨架代码如：

[source,js]
----
    // 标准模块的书写方法（带企业信息的加载）
    componentDidMount() {
        Ex.yiStandard(this).then(Ux.pipe(this));
    }
    
    
    // 纯 Assist 数据加载
    componentDidMount() {
        Ex.yiAssist(this).then(Ux.ready).then(Ux.pipe(this))
    }
----

注意此处的组件本身是经过了 `@Ux.zero` 的资源文件绑定过的，若是纯组件不具备加载 Assist 的条件（Form除外，新版表单和流程拥有内置的 `assist` 驱动流程）。

===== 关于继承

Assist 辅助数据还有一种定义方式如：

[source,json]
----
{
    "_assist": {
        "user.departments": {
            "uri": "/api/dept/by/sigma",
            "inherit": "resource.departments"
        },
        "user.teams": {
            "uri": "/api/team/by/sigma",
            "inherit": "resource.teams"
        },
        "ajax.groups": {
            "uri": "/api/group/by/sigma",
            "inherit": true
        }
    }
}
----

上述辅助数据定义中，采用了 **继承**，数据继承的结构图如下：

image:exp-app-assist.png[0,700]

上述结构图中可以知道，一般 **父组件** 的辅助数据来自两个方向：

- 自身的 `props`：一般辅助数据来自父组件
- 自身的 `state`：一般负数数据来自自身组件的加载

而这些数据会在往子组件传递时合并到子组件的 `props` 中，**继承** 功能点如下：父组件将字典 `dict.name1` 传入子组件中时，若子组件中出现了同名字典定义 `dict.name2`，此时这个字典就可以开启 **继承** 功能，继承有两个值：

- true：子组件中的辅助数据和父组件辅助数据开启同名继承。
- String：子组件中的辅助数据为父组件中的辅助数据开启别名模式（数据本身从父组件继承而来）

[TIP]
====
继承最大的好处是防止 **组件嵌套** 层次比较深时，同名字典出现了多次从远程加载的情况，正常模式下字典本身在一个 **页面** 级维持一份是最好的安排，但往往实际开发过程中不会这么简单。
====

===== 批量配置

前边所有示例都是**单字典模式**，为了减少前后端交互，针对 `TABULAR / CATEGORY` 这两种字典类型前端提供了快速配置通道，使用此配置可以帮助 **开发人员** 执行**批量配置**，但这种配置模式仅针对 `TABULAR / CATEGORY` 有效。参考下边配置：

[source,json]
----
{
    "_assist": {
        "tabular": {
            "uri": "/api/types/tabulars",
            "method": "POST",
            "magic": {
                "$body": [
                    "norm.law.type",
                    "norm.law.policy"
                ]
            },
            "group": "type"
        }
    }
}
----

`_assist` 节点的子节点下边有两个特殊节点：

[options="header",cols="3,7"]
|====
|节点名|含义
|`tabular`|列表类型的字典配置，只访问 `X_TABULAR` 表。
|`category`|树型的字典配置，只访问 `X_CATEGORY` 表。
|====

此处您可以关注的配置是 `group`，此处的 `group` 表示您读取出来的所有字典是按什么属性（此处的 `type`）进行分组，分组之后，这样一个配置会往后端发送一次 Ajax 远程请求，但 `type` 有多少种最终就生成多少字典，简单说上述配置在底层会生成两个字典，底层等价于：

[source,sql]
----
-- 实际执行的SQL
SELECT * FROM X_TABULAR WHERE `TYPE` IN ('norm.law.type', 'norm.law.policy');

-- 但是上边配置在前端会对应如下设置
-- 字典一：norm.law.type
SELECT * FROM X_TABULAR WHERE `TYPE` = 'norm.law.type'     -- 等价SQL，实际不执行
-- 字典二：norm.law.policy
SELECT * FROM X_TABULAR WHERE `TYPE` = 'norm.law.policy'   -- 等价SQL，实际不执行
----

简单说最终数据集会按照 `type` 进行分组，每组一个字典，而字典名称就是 `type` 的值。

==== synonym 同义语义

[CAUTION]
====
**动态建模**中，由于模型本身已经携带了属性别名，加上 `UI_LIST / UI_FORM` 可以作为模型专属来对待，一般不使用 `synonym` 语义（虽然也支持）。往往在动态建模流程过程中，表单和列表的属性名在自身配置中可定义，而属性名本身就具备两层语义：**模型层 / 展示层**，加上内置了映射组件保驾护航，根本不用担心第二形态的存在。这种模式下直接采用传统方式的 **拷贝**（此时的拷贝是低成本的），就可以直接完成大量的新模型、表单、列表模块的开发，所以此时 `synonym` 的语义显得比较 **鸡肋**。
====

`synonym` 同义语义一般在常用框架中都不会存在，开发人员完全可以使用 **拷贝/复制** 大法直接在 OOB 的基础上做一个新的模块，但是这样的代价是维护的成本比较高。`synonym` 语义处理的是 **业务多态** 的场景（目前版本主要做 **呈现层** 标签重命名）：

image:exp-form-synonym.png[]

此 **语义** 的优势在于应付 **需求变更**。它的诞生原因：

1. OOB 标准化模块一直处于开发和变动状态，如果使用传统的 **直接拷贝** 的方式，整个模块的版本会变得不容易维护，而每次开发完成之后您必须使用 **拷贝** 的方式将变更部分更新到新系统中，这样一旦出现大的基础模块的变动，您的整个系统升级会变得复杂——也可以理解 `synonym` 是一种面向升级的语义。
+
--
[TIP]
====
这种设计和 Zero Ui 中采取最初的 **分发器** 模式改成如今的一个单独的自动化指令：`ai sync` 是如出一辙，虽然这个命令目前也是使用的 **拷贝**，但 **拷贝** 这个动作是机器托管，自动分析，自动计算，最终类似自动化更新程序来更新框架，且更新部分禁止开发人员改动。
====
--

2. 部分扩展的力度并没有达到要底层的表结构和模型发生变动，这种场景下拷贝完整的表、实体、模型无疑是一种 **杀鸡用牛刀** 的玩法，为了避免这种玩法，`synonym` 语义可以让您单纯从 **业务语义** 上穿一件外衣，而不去改动底层（接口可以使用统一授权模式，也可使用分离授权模式）。典型场景如：员工管理扩展出供应商员工管理、驻场员工管理、合作伙伴员工管理、内部员工管理，在目前的 OOB 模式下，基础的 `E_EMPLOYEE` 一直都岿然不动，只是单纯通过拓展的方式来实现：
+
--
- 若没有任何新属性的需求，仅需将部分 **展示层** 重命名，如 `员工工号 -> 驻场员工编号`，这种级别的变更直接用 `synonym` 同义语义是最快的。
- 若出现了新的属性的需求，那么可以采取 **父主表** 或 **父从表** 两种连接模式也可以达到新增属性的需求，但这种模式下，OOB 标准模块中的属性依旧依赖 `synonym` 同义语义来装饰。
--

所以，同义语义既可以保证 **已运行模块** 的升级、变更、扩展流程，又可以兼容新模块的开发，还支持部分已存在的模块直接 **积累/沉淀** 成标准化模块，可谓一举三得。

===== 表单配置

同义语义的表单配置位于 `_form` 节点之下：

[source,json]
----
{
    "_form": {
        "synonym": {
            "name": "退款单标题",
            "amount": "退款金额"
        }
    }
}
----

同义的表格示例（下边配置中不再解释）

[options="header"]
|====
|属性|OOB标准化模块|同义后标签
|name| 单据标题 |退款单标题
|amount| 单据金额 |退款金额
|====

由于在目前版本的收款单、退款单两个核心对象中很多属性都是重复的，仅金额的正负不同，此时这两种模型出现了 **同质化设计**，于是 **同义** 语义就十分有作用，几乎“零成本”的方式就可以改造出两个新的基于标准化模块继承过来新模块（只是底层共享了表结构）。

===== 列表配置

同义语义的列表配置位于 `_grid` 节点之下（参考 `Ex.yiListSynonym` 用法）：

[source,json]
----
{
    "_grid": {
        "synonym": {
            "title": "法规标题",
            "description": "法规文档备注"
        }
    }
}
----

===== 流程表单配置

同义语义的流程表单配置位于工作流定义的 `UI_CONFIG` 部分，通常如下：

[source,json]
----
{
    "synonym": {
        "phase": "销毁单状态",
        "title": "销毁单标题",
        "serial": "销毁单号"
    }
}
----

===== 编程配置

编程过程中处理起来就更加简单，直接搜索 Zero Ui 中的 `$synonym` 关键字就可以看到多数组件支持的同义语义部分，此处就不赘述，在后续实战章节注意拆解和讲解。

==== 自定义组件

===== 分类

Zero中的自定义组件主要分为三个大类：

- 标准组件：技术型，不绑定 `zero-extension` 的业务，可独立成纯技术组件使用：
+
--
[source,js]
----
import {InputArray} from 'web';
----
====
由于标准组件已经被 link:#__WEB_FORM_FIELD[字段配置] 完美封装，您可以直接在 JSON 中书写标准组件配置而不去关心如何编程，所以这部分内容会变得非常 **傻瓜式**。
====
--
- 扩展编程组件：业务型，直接和 `zero-extension` 中的模块绑定，必须在后台启用了部分 Zero Extension 中的接口才可用：
+
--
[source,js]
----
import {ExLinkage} from 'ei';
----
--
- 扩展配置组件：业务型，后端必须启用 `zero-ui`，这种组件是为动态界面量身打造的组件，不可以透过编程模式去实现相关内容。
+
--
[source,js]
----
import {OxTab} from 'oi';
----
--

三种组件使用场景会有所不同，**标准组件**是隔离业务存在的组件，目前大部分组件都是 `<Form/>` 中常用的自定义表单交互式控件，当然除此也会包含类似**拓扑图编辑器、报表呈现、文档阅览器**等集成第三方专用的相关组件信息。而扩展组件分**编程**和**配置**两条线，其中**编程**模式是目前版本的主要内容，提供给开发人员快速开发专用（当然前提是您使用了 Zero Extension 扩展），**配置** 组件在 CMDB、ITSM、ISO 等标准化核心领域中十分常用，不过依赖后端的 `zero-ui` 模块实现动态定制化所见即所得的模式。

===== 组件前缀

参考下边表格看不同组件前缀含义：

[options="header",cols="3,3,14"]
|====
|前缀|分类|含义
|（无）|标准组件 a|

- `web` 包，代码位于 `src/economy` 目录中。
- 这种组件复用程度十分广泛，可以理解成单纯的 `React, AntD` 的相关扩展，纯技术型组件。
- 组件名称不带前缀（照顾开发人员习惯）。
- 这些组件中表单交互式组件部分目前已经完美契合到表单配置中，同时支持：**编程**和**配置**两种模式。
| `Dx` |扩展组件 a|

- **D** 的含义为 Development。
- `ei` 包，代码位于 `src/extension/ecosystem` 中。
- 开发中心专用扩展组件。
| `Ex` | a|

- **E** 的含义为 Extension。
- `ei` 包，代码位于 `src/extension/ecosystem` 中。
- 直接和 Zero Extension 模块对接的扩展组件，又称为标准扩展组件。
| `F` | a|

- **F** 的含义为 Finance。
- `ei` 包，代码位于 `src/extension/ecosystem` 中。
- 和**财务系统**相关的专用扩展组件，本身依赖 Zero Extension，并且依赖 `zero-fm` 扩展。
| `G2` | a|

- **G2** 就是 AntD 中的图表名。
- `ei` 包，代码位于 `src/extension/ecosystem` 中。
- 二维图表专用组件，后期报表中心会直接使用里面的组件做相关报表。

====
正常来说，G2 部分应该直接归并到标准组件中，但由于历史原因，加上 G2 版本还等待着一次比较大的升级，所以现阶段无法直接将 G2 的组件放到标准组件处理。
====

| `Ix` | a|

- **I** 的含义为 Internal。
- `ei` 包，代码位于 `src/extension/ecosystem` 中。
- `<Form/>` 开发中心交互式组件专用扩展，里面存储的是更加复杂的数据库交互式可重用组件，由于本身依赖后端业务信息，无法放到标准组件中开发，如：数据库配置器、集成配置器等。
| `My` | a|

- **My** 的含义就是 **我的**，表示个人设置。
- `ei` 包，代码位于 `src/extension/ecosystem` 中。
- 此类组件为新组件，对接底层的 `zero-tpl` 部分，您可以根据自己的保存信息将个人设置存储，如：首页小配件、布局、风格、列表默认入口等。
| `Qx` | a|

- **Q** 的含义为 QrEngine。
- `ei` 包，代码位于 `src/extension/ecosystem` 中。
- `<Form/>` 复杂查询条件录入专用的交互式控件。
| `Tx` | a|

- **T** 的含义为 Task。
- `ei` 包，代码位于 `src/extension/ecosystem` 中。
- 这类组件目前只是**工作流引擎**专用的控件，不会牵涉任务系统，由于后续可能还会包含基本任务、签到等功能，所以前缀使用了**T**而不是**W**。
| `Hx` | a|

- **H** 的含义为 High Order，高阶。
- `ei` 包，代码位于 `src/extension/ecosystem` 中。
- 高阶组件目前仅用于权限管理部分，后续很长一段时间也会遵循此规范来进行。
| `Ox` | 配置组件 a|

- **O** 的含义为 Origin，起源。
- `oi` 包，代码位于 `src/extension/eclat` 中。
- 配置组件是动态建模必须的组件，它内置可能会调用 `Extension` 的扩展组件，但一般不会在开发过程中直接使用，都是使用 `JSON` 配置数据驱动来完成整体交互，这套组件几乎是为 `zero-ui` 量身打造的组件。
|====