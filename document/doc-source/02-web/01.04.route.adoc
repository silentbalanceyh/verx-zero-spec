ifndef::imagesdir[:imagesdir: ../images]
:data-uri:

=== 路由解析

本章详细解析前端路由表，方便开发人员开发和路由相关的功能。

==== 数据预处理

[options="header"]
|====
|类型|含义
|`TOP-MENU`| 顶部个人头像部分专用菜单
|`EXTRA-MENU`| 顶部个人头像旁附加菜单（帮助、提醒、开发中心）
|`BAG-MENU`| 应用入口菜单
|`SIDE-MENU`| 主站点菜单
|====

除开上述四种菜单以外的菜单都不会出现在个人**主菜单**的模板中，数据预处理则是针对菜单的核心数据结构执行处理，构造合法**路由树**。

===== 应用提取

应用提取依赖模块化配置，即 `B_BAG` 中的核心配置，当你登录系统之后，您可以直接使用如下代码从前端提取应用配置：

[source,js]
----
// 全局配置提取
const app = Ux.isInit();
// 应用配置提取
const { bags = []} = app;
----

上述代码中的 `bags` 存储与 `B_BAG` 表中，它有两个控制配置的核心属性：

- `entry ( ENTRY )`：是否入口模块，只有入口模块可以挂菜单。
- `entryId ( ENTRY_ID )`：入口模块关联菜单名。
+
--
- 菜单必须是 `BAG-MENU` 类型的菜单。
- 菜单名称必须存在，`X_MENU` 表中的 `NAME` 记录和 `B_BAG` 中的 `ENTRY_ID` 记录匹配。
--

缺乏配置和菜单都会导致应用提取失败，提取失败的应用不会出现在左上角，此处解释一下**应用**的概念，让开发者此处不会困惑（由于教程中多次提到了应用，而前期模块化不成熟时没有区分，所以需解惑）。

[options="header",cols="3,7"]
|====
|概念|含义
|租户应用|对应到 `X_APP` 表中的唯一记录，它表示当前系统运行的核心应用。
|业务应用|模块化应用，统称 App，在当前环境中左上角可以展开的应用，系统底层为应用包，对应 `B_BAG` 表中的唯一记录。
|模块|位于 `B_BAG` 之下的结构，用于描述单独对应的某个路径如下下的模块配置信息。
|====

上述完整拓扑如下：

image:zapp-r-extension.png[,900]

[WARNING]
====
从图上可以知道，此处的 **模块化** 和 **动态配置** 都是扩展模块中的内容，您可以不启用，不启用的时候依旧可以依靠 `X_APP / X_MENU / X_MODULE` 完成模块的完整配置。

[options="header"]
|====
|模块|功能
|`zero-ui` | 提供 `UI_` 系列表，绿色，负责界面动态化配置。
|`zero-battery` | 提供 `B_` 系列表，橙色，负责和开发中心桥接的纯模块化配置。
|====

Zero中有一个不成文的规定就是**页面**本身只支持三级，对应核心中枢路由：`/:app/:module/:page`，在这种模式下您可以使用这三个参数直接提取 **模块配置** 和 **页面配置**，没有配置数据不影响前端原生开发，有配置数据时您只是在开发过程中多一种选择。路由解析器和配置分流器会帮助你完成配置的管理和连接部分，路由解析原理就是本章的核心知识点。
====

===== 菜单标准化

菜单标准化属于预处理的一部分，目前版本做了如下标准化行为，对应模板、行为、配置数据格式化处理，代码位于 `src/utter/kind.fn.a4.menu.item.js` 中。

[options="header",cols="3,7"]
|====
|类型|行为
|全部|原配置：处理 `X_MENU` 中的 `metadata` 字段，如果此字段是一个纯字符串，将它 JSON 化，实际这个行为有可能在后端已经完成，那么不影响它的注入流程。
|`EXTRA-MENU`| 特殊风格：根据配置字体设置此种菜单的字体大小，特殊风格处理可直接修改 `TYPE_STYLE` 进行**扩展**和注入流程。
|`BAG-MENU` a| 

- 业务应用配置处理，标准化左上角展开的菜单呈现，计算 `desc, icon, bag` 等特定属性，左上角的业务应用主菜单比**主菜单**多一部分额外需计算的信息。
- 注意 `BAG-MENU` 中的图标会**屏蔽**掉菜单配置中的 `icon` 属性，优先考虑 `B_BAG` 中的 `UI_ICON` 对菜单呈现执行定制。
|全部 a|图标多元化：根据不同的图标格式对图标进行规范化处理

- 纯格式直接使用 `icon` 的值，对应到 AntD 中的默认图标选项
- 图片格式则使用 `cab:<name>` 的值，透过 `<name>` 从模块定义中提取（这种模式一般是提取图片）
|====

==== 解析：区域管理

为了兼顾 `react-router` 和 `F5` 刷新两种操作都可以维持菜单基础状态以及老版本的兼容性，所以 Zero UI 中的路由菜单本身是可控的模式，这种模式可以帮助开发人员更细粒度解决路由本身的配置连接和动态扩展。

控制路由过程中，区域管理的基础概念如下：

[options="header", cols="2,8"]
|====
|概念名 | 含义
|`Home` | 全站主页，通常是在 `Z_ENTRY_ADMIN` 中配置的主页信息，会直接跳转到站点主页中。
|`Open` | 展开菜单，此概念不绑定某个页面，主要是设置模板中的 `$keyOpen` 状态值（数组，可是多个），用于记录哪些菜单是被展开的，此操作在 `F5` 刷新时特别有效，否则无法维持菜单的展开闭合状态。
|`Active` | 顶部激活，当菜单使用的是左上两种模式时，依靠 `$keyActive` 记录激活值，保证激活效果（高亮），此值仅适用于当前环境中包含了顶部菜单的情况，若没有顶部菜单与之关联（另外两种布局），那么此值可忽略。
|`App` | 激活应用，会启用 `SessionStorage` 用于定位当前激活的应用，关联左上角应用图标中的内容，和 `Home` 互逆。
|`Page` | 当前页，具体页面，会根据路由变化直接计算内部状态 `_opens` 来实现跨页展开状态信息。
|====

以上五个区域为路由解析器的核心概念，而全站路由解析和状态管理都是依赖此处的概念区域协同完成。

====
代码位于：`src/unfold/allocation.__.c.locator.navigation.ts` 中，由 `_Locator` 类统一管理。
====

==== 解析：Password

应用初始化之后，当用户第一次登录必须修改密码，这种情况下，所有路由解析在同一个模板中都会失效，密码页使用环境变量配置：

[source,properties]
----
Z_ENTRY_FIRST=/personal/secure
----

此页面若您不配置，那么会直接跳过，没有：首次登录改密码的功能，上述配置是 Zero UI 中的默认页。

==== 核心解析

> 当前页查找

当前页查找流程是路由解析的核心原理流程，也是 Zero UI 中最复杂的部分，这部分内容牵涉到页面兼容各个模块的多方计算，代码位于 `src/unfold/allocation.__.fn.seek.uri.js` 中，它的流程如下：

image:zapp-r-parse.png[0,960]

按照上图流程，菜单对应页面主要分为三大类：

[options="header", cols="3,7"]
|====
|类型|含义
|后端配置页|这种菜单就是上边流程中提到的有数据源的菜单，在后端有完整的树型结构存储在 `X_MENU` 菜单中。
|特殊页|特殊页目前有两种：**流程配置页**、**模块配置页**，后续根据内容可扩展，直接在前端固化实现。
|前端独立页|前端独立页一般在前端代码中会存在，通常是扩展出来的独立页面，但它的配置没有出现在后端中（无法执行权限处理，通常无法执行其他扩展配置操作），通常是内置引导页专用。
|====

[TIP]
====
上述页面中只有 **前端独立页** 没有数据源支撑，其他两种页面在后端都带有对应的数据源存储信息。
====

==== 解析：App

应用路由主要用于提取当前应用（全局 / 业务）的主菜单路由信息，它的提取流程如下：

image:zapp-rr-app.png[0,720]

此解析主要用于查找应用首页：

1. 若当前应用是一个业务应用（ `BAG-MENU` ），那么直接返回此菜单实例。
2. 若当前应用是非业务应用，那么直接返回全局首页菜单实例，输入由 `Z_ENTRY_ADMIN` 提供。
3. 在检索业务应用首页过程中，若无法找到合法的业务应用菜单，那么返回全局首页。

==== 解析：Page

当前页路由用于提取所在页面，其中此页面可以是上述核心解析中的三种页面中的任意一种，它的提取流程如下：

image:zapp-rr-page.png[0,720]

此解析主要用于读取当前页：

1. 此解析流程依赖前文提到的 `App` 解析流程。
2. 最终实际会在找到的当前页和应用页二者中 **二选一**。

==== 解析：Open

展开页主要用于提取展开菜单的所有状态，它的提取流程如下：

image:zapp-rr-open.png[0,720]

此解析有几个注意点：

1. 若不跨页，仅考虑当前页的执行，那么此处只检查模板中存在的 `$keyActive` 用于表示当前激活的顶部 **根菜单**。
2. 在 `seekUri / seekApp` 计算时，不仅提取当前页的主键，还提取整棵树上当前分支的所有菜单主键——核心逻辑：**若一个子菜单被打开了，那么它的父菜单一定是打开的**。
3. 提取路由中已经缓存好的 `_opens` 相关信息（跨页跳转时所需），这种情况一般用于从一棵树跳转到另外一棵树中的页面时必须。

[CAUTION]
====
所有解析中，只有 `Open` 类型返回的是一个数组，即展开的菜单是一个键集，并不是单一的菜单。
====

==== 解析：Side

一般模式下，若是解析当前页可直接使用 `Page` 的方式解析到当前页的相关信息，而此处的 `Side` 一般用于解析中间页（二级或多级中的中间级），一般为设置 **默认值** 专用，所以优先级比 `Page` 低。它流程如下：

image:zapp-rr-side.png[0,720]

====
目前的整个路由解析算法在业务应用这一侧暂时没有遇到什么特殊的问题，所以此处暂时不对路由解析算法升级，直接使用即可，后续开发中心搭建之后，可能会有复杂的路由解析算法，但最终可按需设置，但本章节中的路由解析原理开发人员需熟知道。
====

==== 参数 vs 跳转

===== 参数

Zero UI 中的路由管理使用了 `react-router` 路由插件，Zero UI根据参数传参方式将其分为两种：

1. `external`：外部参数，这种类型参数会将参数追加到查询路径之后，如 `name = xxx`，最终会生成 `/path?name=xxx` 格式的路径。
2. `internal`：内部参数，这种参数不会转换成查询路径参数，最终的 `uri` 不会发生变化，但依旧可以直接传到下一个页面中（借用路由内置）。

[TIP]
====
在 Zero UI 中，外部参数和普通参数的用法一致，内部参数则使用 `\_` 做前缀，若您的参数名中带了 `_` 前缀则会自动转换成 **内部参数**，且内部参数会一直递归传输，简单说除非手动清理，否则内部参数会像一个堆栈一样一直在页面和页面中无限制传递，这种特性对复杂页面的组织十分有效。
====

Zero UI 中的内定标准化参数如下

[options="header", cols="2,2,6"]
|====
|参数名|类型|含义
|`aid` | 外部参数 | （保留）应用ID，多应用模式下使用。
|`mid` | 外部参数 | 模块ID，对应动态配置中的模块主键。
|`pid` | 外部参数 | 页面ID，对应动态配置中的页面主键。
|`tid` | 外部参数 | 任务ID，目前只在工作流页面中使用，其他模块中暂时未使用。
|`id` 和 `key` | 外部参数 | 数据记录主键，这两个参数的使用方式和 `tid` 类似，但它提供了更多的模型记录数据提取方式，且二者同语义。
|`target` | 外部参数 a| 此参数比较特殊

- 参数本身执行过 Base64 加密，但内置处理时会自动完成加密解密的过程，保证在浏览器的查询参数中不出现特殊符号。
- 双页面中，target 直接表示上一个页面。
- 多页面中，target 则表示最初的入口页面，若内置出现多层（目前不可配），只能通过编程的方式执行参数传递。
|`_opens` | 内部参数 | 跨页面可用的展开的菜单列表。
|====

===== 跳转

跳转直接使用文档管理中的页面跳转逻辑来解析：

image:zapp-rr-jump.png[0,720]

简单说明：

1. 上述路由图中有一个比较快捷返回 `target` 页面的专用 API：`Ux.toOriginal`（红线部分）。
2. 其他路由跳转一般通过 `Ux.toRoute` 的API来实现。
3. 注意在多层页面中参数的消除以及需要依赖内部传参的点。

上述结构的示例代码：

[source,js]
----
// /law/manage 页面
    const {$router} = ref.props;
    Ux.toRoute(ref, "/law/page-view", {
        target: $router.path(),
        docId: key
    });

// /law/page-view 页面
    // -> /law/page-parsing
    // 跳转页面专用
    const target = Ux.toQuery("target");
    const docId = Ux.toQuery("docId");
    const parameters = {};
    parameters.docId = docId;
    parameters.target = target;
    parameters.clauseId = input.key;
    // 内部传参
    const {$data = []} = reference.state;
    parameters._data = $data;
    Ux.toRoute(reference, '/law/page-parsing', parameters);
    
// /law/page-parsing 页面
    // -> /law/page-view
    Ux.prevent(event);
    const params = {};
    params.target = Ux.toQuery("target");
    params.docId = Ux.toQuery("docId");
    Ux.toRoute(ref, "/law/page-view", params);
    // -> /law/manage
    Ux.prevent(event);
    Ux.toRoute(ref, "/law/manage")
----