ifndef::imagesdir[:imagesdir: ../images]
:data-uri:
:table-caption!:

=== 组件：`DocViewer`[[__WEB_UCA_DOC_VIEWER]]

本章带大家一起开发一个**文档阅览器**，文档阅览器主要用于从远程 `X_ATTACHMENT` 生成的属性中加载对应的文件信息，实现 `Word, PPT, Excel, PDF` 四种不同文件的阅览功能，这是一个新的自定义组件，且不会生成 `aiX` 的**交互式**组件，仅做**文档预览**专用。开发文档阅览器使用的库如：

[TIP]
====
- 最新参考：link:https://github.com/cyntler/react-doc-viewer[@cyntler/react-doc-viewer]

旧版本从**2020**年开始已经没有运维了（最新版 `0.1.5` ），暂时可以搁置在那儿，最新版直接参考上述链接地址，最新版为 `v1.13.0`，其用法一样，后续 Zero Ui会将这部分内容原生支持到框架内部进行持续改造，按开源协议拉一个分支出来自己维护
====

==== 环境搭建

在您的项目中执行如下命令添加依赖包：

[source,bash]
----
 # NPM 模式安装
 npm i @cyntler/react-doc-viewer
 # YARN 模式安装
 yarn add @cyntler/react-doc-viewer
----

这是一个标准化组件，可以直接扔到 `economy` 中去实现，实际在这个项目内您可以看到目录前缀（ `@` 符号之前 ）如下截图：

image:uca-component-economy.png[]

上述结构中 `@` 之前的拼写表示这个组件来自于哪个**内部项目**，即 `z` 开头的一系列底层项目，由于 `DocViewer` 的目的是做文档阅览，所以此处选择直接放到最上层处理：

[options="header",cols="2,2,6"]
|====
|前缀|目录|含义
|`web`|`economy`|直接在标准组件中定义文档阅览器，此处有个特殊点在于此文档阅览器会解析 `X_ATTACHMENT` 的数据结构，所以更好的方式是直接放到 `extension` 部分，但我希望Zero核心框架中自带**文档阅览器**，和**拓扑分析图**一样，形成一个最基础的组件来加载不同的二进制文件流。
|====

按照如下步骤创建此自定义组件（ 自定义组件只能在项目 <https://gitee.com/silentbalanceyh/scaffold-ui.git> 中开发，`ai sync` 命令会读取此项目做框架层同步 ）：

1. 在 `economy` 目录下创建一个新目录：`web@DocViewer`。
2. 按照 Zero Ui 的基础规范，目录中创建入口文件 `UI.js`，文件内容如下：
+
--
_旧版写法（class模式）_

[source,jsx]
----
import React from 'react';

class Component extends React.PureComponent {
    render() {
        return (
            <div>
                <h1>Doc Viewer</h1>
            </div>
        );
    }
}

export default Component;
----

_新版写法（hook模式）_

[source,jsx]
----
import React from 'react';

const Component = (props) => {
    return (
        <div>
            <h1>Doc Viewer</h1>
        </div>
    );
}

export default Component;
----

[CAUTION]
====
新旧版本的选择在于您是否要启用 `Ux.zero` 的**注解**，若使用注解和资源文件绑定，那么依旧采用 `class` 模式开放是最好的选择，若您的组件内部无需启用**资源文件绑定**的功能，那么可以直接使用 `hook` 模式开发。
====
--

3. 写好之后更改入口文件 `index.js / index.d.ts`：
+
--
[source,js]
----
    // 都追加如下导出信息：
    export {default as DocViewer} from './web@DocViewer/UI';
    
    // 消费端使用：
    import {DocViewer} from 'web';
----
--

4. 提交 `scaffold-ui` 中的 PR 并且在自己项目中执行 `ai sync` 同步对应代码就可以使得此组件生效了。

==== 文件下载

文档阅览器中使用的数据结构在 Zero Ui 中是直接对齐了 `X_ATTACHMENT` 记录的数据结构，此数据结构如：

[source,json]
----
{
    "key": "???",
    "name": "论文范文.docx",
    "extension": "docx",
    "type": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "mime": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "size": 16644,
    "status": "DONE",
    "directoryId": "???",
    "storeWay": "STORE",
    "storePath": "/apps/nm/document/合规文档/法规库/LAW2309071001/论文范文.docx",
    "modelId": "nm.law",
    "modelKey": "???",
    "modelCategory": "DOC.NORM.LAW",
    "fileName": "论文范文",
    "fileKey": "???",
    "fileUrl": "/api/file/download/xxx-of-download",
    "filePath": "file-uploads/xxx-of-upload",
    "active": true,
    "sigma": "???",
    "metadata": {},
    "language": "cn",
    "createdAt": "2023-09-07T11:44:23",
    "createdBy": "???",
    "updatedAt": "2023-09-07T11:44:23",
    "updatedBy": "???",
    "visitGroup": null,
    "visitRole": null,
    "visitMode": [
        "r",
        "w",
        "x"
    ],
    "visit": false,
    "directory": false
}
----

上述数据结构描述了远程存储的文件基本信息，此处对**文件阅览器**而言，最核心属性如：

[options="header", cols="25,75"]
|====
|属性|含义
|`name` |文件原始名称，下载时也可以使用此名称存储到客户端。
|`mime / type` |文件的MIME，此属性很重要，它描述了远程文件的核心格式，虽然**文档阅览器**可以通过后缀名对文件类型进行区分，但 `mime` 是文件类型上传时留下的最本质的元数据，它可以作为**严格模式**下的文件验证基础，防止用户恶意篡改后缀名导致非法攻击行为。
|`fileUrl` |下载文件专用的地址，内置会调用 `Ux.ajaxDownload` 的方法来从远程拉取文件的二进制数据内容（也是本小章节需完成的开发内容）。
|`fileKey` |文件唯一键，此唯一键在后端可跨任何系统做全局**唯一**的标识，从云存储角度打破了所属的维度概念，简单说整个平台上传的文件都只有一个唯一的`fileKey`。
|====

由于 `DocViewer` 使用的是 `class` 模式的开发，文件下载流程应该在 `componentDidMount` 方法中设置，并在预览之前初始化好组件状态。
