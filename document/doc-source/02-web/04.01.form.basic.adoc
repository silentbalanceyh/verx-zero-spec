ifndef::imagesdir[:imagesdir: ../images]
:data-uri:
:table-caption!:

=== 表单开发

Zero UI中的表单开发主要以配置为主，而在开发过程中可直接使用模板代码进行开发，开发人员真正需开发的部分：

1. 开发 `Op.js` 针对表单中的提交部分执行函数开发。
2. 开发 `UI.js` 的入口表单开发。

表单的基础配置以两部分内容为主。

1. 配置加载：直接从 `UI.json` 中提取 `_form` 的配置信息，或从远程访问读取 `JSON` 部分的数据构造表单基础配置。
2. 渲染标准化：调用 `Ex.yoXxx` 系列方法对表单配置执行标准化处理，最终传入 `ExForm` 组件中执行表单扩展处理。

==== 基础Json

[source,json]
----
{
    "_form": {
        "layout": "??",
        "className": "??",
        "window": "??",
        "columns": "??",
        "ui": [
            []
        ],
        "assist": {},
        "hidden": [],
        "initial": {},
        "rule": {},
        "op": {},
        "io": {},
        "metadata": {},
        "segment": {},
        "modal": {},
        "rowConfig": {},
        "rowClass": {}
    }
}
----

上述结构是目前比较常用的一个表单配置的基本结构，也是开发人员必须掌握的完整表单配置结构信息，这份结构基于代码梳理，部分的变化结构并没有在文档中指出，后续可持续更新。

===== 布局属性

Zero UI 中的表单开发使用的是 `AntD` 中的 `<Form/>` 标签，它的布局并没有使用官方的 **流模式**，而使用了经典的 `Grid` 布局模式（24列），控制表单布局的主要有如下属性：

- `window`：选择布局类型，Zero UI中提供的布局类型的值有如下：

+
--
[options="header",cols="1,2,7"]
|====
|值|类型|含义
|`1`|标准布局|（默认值可不填写）常用的表单标准布局
|`1.1`|增强型标准布局|对字段的标签文字进行了深度考虑之后更符合复杂表单的核心增强型布局，某些场景下比 `window=1` 的布局更好用。
|`0.15`|9:15布局|左侧带有很宽页边距的布局模式，一般是 `1` 列字段的表单布局专用，此处 `9:15` 表示一个输入字段中的 **标签:输入控件** 的横向布局信息。
|`0.16`|9:15宽文布局|增强型 `0.15` 的布局模式，针对某个字段 **文字比较多** （如七个字、八个字）的专用布局，一般 `0.15` 时候标签文字不超过四个的布局方式。
|`0.17`|9:15子表单布局|增强型 `0.15` 的布局模式，若此表单中包含了 **子表单**，那么这种布局模式更适合。
|`0.21`|Word布局|这种布局模式属于之前认证评价系统专用布局，表单本身就是一个Word文档，格式也是参考Word文档的格式执行深度定制。
|`0.5`|两列标准布局|常用的 `2` 列字段的标准布局，通常两列是 `12:12` 的方式。
|`0.51`|两列变种布局|类似 `1 -> 1.1` 的变体一样，这种类型两列布局可以解决 **文字较多** 的场景。
|`0.101`|10:14布局|新布局模式，**标签:输入控件** 横向比例 10:14
|`0.121`|12:12布局|新布局模式，**标签:输入控件** 横向比例 12:12
|`-0.3`|抽屉搜索表单|右侧抽屉拉出来之后的表单布局模式。
|`-0.5`|高级搜索表单|点击了 **高级搜索** 之后的布局方式。
|====

上述布局设置中参考如下注意事项：

[CAUTION]
====
1. 若要扩展新的布局，您可以直接更改 `src/zion/variant-layout/` 中新增布局定义文件、扩展新值即可，键使用浮点数。
2. 一般在表单布局中，**负数** 表示过滤搜索表单布局，**正数** 表示提交型表单的布局，大于 `1` 表示高频布局，小余 `1` 则表示特殊变体。
====

布局本身设计如此复杂也是有 **历史原因** 的，在早期的 `AntD` 和新版本的 `AntD` 中，标签对齐都是直接在编程代码中手工设置，这样的模式会导致大量布局前端的重复代码，且上下字段对齐特别是标签对齐相对麻烦，所以才有了Zero UI中的布局自动计算，布局解决的核心问题是在 **字段占用 Grid 布局中的列不同但上下标签依旧是对齐的**，这样的解决方式虽然在设置值时会略微复杂，但可以解决超过 `300` 个字段的大表单的上下布局问题。
--

- `columns`：选择此布局类型中每一行默认容纳的字段数量。
+
--
该值相对比较简单，牵涉到每一列的 `span` 的自动计算，Zero UI会根据 `window` 和 `columns` 两个值自动计算单个字段的 `span` 属性，让Grid布局更具智能化，某些标准模式下几乎不需要设置 `span` 就可以完成上下完整对齐。

[options="header",cols="2,8"]
|====
|值|含义
|1|单列表单，每一行只有一个字段，标准模式下：`span=24`。
|2|双列表单，每一行有两个字段，注 `0.5 / 0.51` 只支持 `columns=2` 的情况，标准模式下：`span=12`。
|3|三列表单，每一行三个字段，标准模式下：`span=8`。
|4|四列表单，每一行四个字段，标准模式下：`span=6`。
|====
--
- `layout`：对应 `AntD` 中的属性值，默认是 `inline`，可支持的值包括：`horizontal、vertical、inline`。

布局除开上述三个属性以外，还有针对单行的处理属性：`rowConfig`，在 `rowConfig` 中您可以针对某一个行（索引为键值）的布局执行修正效果，造成模式和模式之前横向的变体，这样其布局就可以突破单个布局的局限性，如 `1` 和 `0.15` 的混用时，可能依赖调整 `rowConfig` 来达到 **对齐** 的效果，若没有此配置那么 `window` 一旦指定表单就会被固化下来，而在更多复杂场景时 **布局固化** 是一个十分可怕的事。

[NOTE]
====
关于布局有一个可能困惑开发人员的东西，就是表单渲染中的 `key` 值，此处的 `key` 值您可以直接从 `Console` 的表单渲染器中看到：

image:exp-form-layout.png[]

此处解释下 `key` 值的含义，一般 `key` 值有四位，如截图中的 `3008`：

[options="header", cols="2,1,7",title="从左往右"]
|====
|位数|示例|含义
|第一位|`3`|表示当前表单布局的默认列数，只支持 `1,2,3,4` 四个值。
|第二位|`0`|表示当前属性在这一行的列索引，如 `0` 表示从左往右的第一个表单属性。
|第三、四位|`08`|表示当前属性占用的宽度，按 Grid 排版，此处使用的值最终为 `span=8`。
|====

上述模式中既可控制到**行**，又可以控制到**列**，有了 **行列** 配置之后，您可以很容易对当前表单中的组件进行定位，此处解读 `key` 的目的是为了对应布局文件中的如下内容：

[source,js]
----
const layout = {
    // ...
    2016: "4,20,98",    // ---- ---- ---- ----
    2108: "8,16",       //                     ---- ----
    2118: "3,21,98",    //        -- ---- ---- ---- ----
    // ...
}
----

上述布局文件中的左值就是 `key`，您采用什么 `key`，那么 `label / input` 的比值就是多少，而第三位如 `98` 表示当前组件的宽度百分比，最终会解析 `98%`。宽度百分比的目的是上下对齐专用。

====

===== 风格属性

风格属性主要有如下两个属性：

- `className`：当前表单的专用属性，默认值 `ux_form`，若您指定了 `className` 之后，那么指定的值将会直接追加和覆盖原始的 `ux_form`（原始风格依旧生效）。
- `rowClass`：针对表单单行的属性设置，您可以在一个完整的基于 `Grid` 的表单中设置某些行特殊的风格信息，如交叉行、反色单行、协变宽高等。

===== 数据处理

数据处理属性主要包含如下属性：

- `assist`：辅助数据（字典数据）表单内加载流程。

+
--
表单内若某些字段绑定了字典信息来构造 **下拉、多选、单选** 等相关信息，这种场景下表单本身依赖字典数据来构造 **可操作源**，而辅助数据的绑定存在两个不同版本的跨越：

- 外部源 `_assist`：此配置位于页面级，不在表单内部，表单内部不用设置任何 `assist` 的属性，依旧可以使用字典数据绑定。
- 内部源 `assist`：此配置位于表单级，在表单内部初始化流程中会被触发，配置格式是一致的。

外部源的模式比较适合 **开发模式**，而内部源多用于 **配置模式**。
--

- `initial`：初始化数据

+
--
初始化数据一般用于添加类 `mode=ADD` 表单，您可以直接在 `initial` 中根据所需对字段执行添加表单的默认值配置，配置片段如下：

[source,json]
----
{
    "initial": {
        "active": "BOOL:true",
        "appId": "PROP:app.key",
        "type": "FIX:ftp",
        "protocol": "ftp",
        "port": "21",
        "path": "/"
    }
}
----

从配置格式可以知道，表单中的初始化数据是支持 **输入属性解析** 功能的，若您设置的字段值带有 `PREFIX:` 的前缀，那么此属性会使用 **输入属性解析** 功能从不同的数据源来填充初始值。
--

- `rule`：延迟初始化
+
--
如果系统中包含了 `linker` 类型的字段影响连接，那么通常在 Zero UI中使用的是 `fieldName / fieldId` 的模式进行双字段渲染，然后填充对应渲染的数据，可是会出现一种情况：**若此处的 fieldName 是另外一个字段** 的数据，并非和 `fieldId` 绑定的数据那么应该如何操作？此时您可以自定义新的数据加载流程，此加载流程在 `rule` 中设置，参考如下片段：

[source,json]
----
{
    "_form": {
        "rule": {
            "parentName": {
                "seeking": {
                    "uri": "/api/x-category/:key",
                    "magic": {
                        "module": "fm.subject"
                    }
                },
                "linker": {
                    "owner": "owner"
                }
            }
        }
    }
}
----

简单讲解下上述配置来理解 `rule` 属性的延迟初始化效果：

- 上述表单中 `parentName` 属性名并非对应的是 `parentId`，此种情况下依赖此处定义的规则在用户读取表单数据时多执行一次数据提取流程。
- 不仅如此，这种数据规则可访问远程的某个接口将抓取的数据通过 Zero UI中的 `linker` 机制默认填充各种数据字段，如此处填充的 `owner -> owner`，此处可设置更复杂的延迟初始化规则。 
--

- `io`：输入/输出规则（非异步）

+
--
输入/输出规则配置属于 **高级话题** 的内容，现阶段通常用于流程表单中做复杂提交，配置片段参考如下：

[source,json]
----
{
    "io": {
        "writer": {
            "record": {
                "inSource": "linkageAsset",
                "inPath": "targetData",
                "outType": "ARRAY"
            }
        }
    }
}
----

- **输入** 表示表单加载过程中的数据初始化流程。
- **输出** 表示表单提交过程中的数据收集流程。

此部分内容在后续实战中逐一讲解，一般使用场景如下：

- 字段数据格式和提交到远程数据格式不完全对齐的情况下，依赖 `io` 规则补充、追加、转换部分字段数据。
- 针对数据本身 Array / Object 两种不同数据格式之间的切换，以适配提交数据。
- 您可以将 `io` 规则理解成表单生命周期中的 `AOP` 行为，可自定义 **加载、交互、提交** 等不同生命周期的表单数据行为。
--

===== 字段属性

字段属性在 Zero UI 中包含两个：

- `ui`：针对可见字段属性的定义。
+
--
此属性的数据结构是一个二维数组：

[source,js]
----
[
    [
    ],
    [
    ]
]
----

二维数组描述的是 `Grid` 布局的基本骨架：

- 一维表示的是当前表单有多少行，`rowConfig / rowClass` 就是作用于一维配置。
- 二维表示的是某一行内的字段信息，由于是一个 Array 结构，所以有多少 `{}` 单元格配置元素当前行就包含多少字段。
--
- `hidden`：不可见字段的属性定义，`hidden` 不参与布局。

===== 安全属性

安全控制关注的属性是 `op`，此属性描述了当前表单中操作的 **安全定义**，现阶段的版本还没完全实现表单的细粒度控制，只要按钮可以呈现那么对用户而言就可以触发表单的提交，而 `op` 属性可直接实现和 `S_ACTION` 的绑定关系，这样绑定之后会造成用户在点击提交时可能会触发 `403` 异常，简单说就是：**您可以看到这个表单，但是当你触发提交操作时，无权限访问接口**。

===== 回调属性

回调属性和Ajax中的回调属性如出一辙，定义的是表单提交完成之后的回调行为：

- 弹出成功弹窗提示操作成功。
- 显示成功消息提示。

回调属性的配置片段如下：

[source,json]
----
{
    "modal": {
        "success": {
            "open": "您好，您的流程申请已成功提交，申请单号 :serial，请等待审批。",
            "draft": "您好，您的流程申请已成功保存为草稿！单号为 :serial。"
        }
    }
}
----

[CAUTION]
====
回调属性是新版提交按钮的配置，在新版按钮配置中，您可以设置 **原子属性**：`closable=true,callback=open`，设置了上述原子属性之后，表示：

- 当前表单提交之后触发 `rxClose` 函数，通常是：**关闭弹窗**、**关闭页签**、**关闭页面** 等行为。
- 弹窗内的文字显示 `modal` 定义中的 `open` 对应文字，即上边示例中的：`您好，您的流程申请已成功提交，申请单号 :serial，请等待审批。`，其中消息中的参数会被 `response` 中对应的数据替换。
====

==== 骨架代码

若您配置了上述的表单之后，可直接书写骨架代码来完成表单的整体组件开发。

===== 源代码 UI.js

[source,js]
----
import React from 'react';
import Ux from 'ux';
import Ex from 'ex';
import {ExForm} from 'ei';
import Op from './Op';

@Ux.zero(Ux.rxEtat(require('../Cab'))
    .cab("UI.Add")
    .to()
)
class Component extends React.PureComponent {
    render() {
        const form = Ex.yoForm(this, null);
        /*
         * 如果是更新，上述代码改成
         * const {$inited = {}} = this.props;
         * const form = Ex.yoForm(this, null, $inited);
         */
        return (
            <ExForm {...form} $height={"300px"}
                    $op={Op.actions}/>
        );
    }
}

export default Component;
----

针对上述代码说明几点：

1. 一般表单开发会使用 `ei` 库中的 `ExForm` 组件，此组件还会帮助您完成各种智能模式处理（已在生产环境验证很高频的用法，减少代码量）。
2. 表单和资源文件绑定之后，会直接从 `cab/cn/` 目录下抓取 **名空间** 对应的JSON配置文件。
3. 此处的行为模式主要绑定 `Op.js` 中的 `actions` 变量，此变量定义在下边有说明。

[WARNING]
====
Zero UI中不推荐将文本呈现放到 JS 文件中，通常一个组件会包含两部分：

- 资源文件绑定部分：`cab/cn/` 下的资源文件定义，此处的资源文件定义实际在处理组件配置时会实现组件配置分流
+
--
- 前端资源文件绑定，根据 `Z_LANGUAGE` 抓取资源文件目录实现 **多语言** 架构，通常是 OOB 专用的方式。
- 后端静态资源绑定，若是 **项目** 静态开发模式，直接从后端 `src/main/resources/cab/cn/` 中读取资源文件。
- 后端动态资源，直接启用后端的 `zero-ui` 模块从 `UI_X` 系列表中读取动态配置。
--

不论是前端还是后端都可以直接在配置提取过程中读取不同的 **语言资源文件**，这样的模式下会保证您的界面实现最大限度的灵活定制，若想要从 **中文** 切换到 **英文**，只需要更改资源文件信息即可，不用对源代码进行任何调整。
====

===== 操作代码 Op.js

[source,js]
----
import Ex from 'ex';

const $opAdd = (reference) => params => Ex.form(reference).add(params, {
    uri: "/api/role",
    dialog: "added",
});
const $opSave = (reference) =>
    params => Ex.form(reference).save(params, {
        uri: "/api/role/:key",
        dialog: "saved"
    });
const $opDelete = (reference) =>
    params => Ex.form(reference).remove(params, {
        uri: "/api/role/:key",
        dialog: "removed"
    });
const $opFilter = (reference) =>
    params => Ex.form(reference).filter(params);

export default {
    actions: {
        $opAdd,
        $opSave,
        $opDelete,
        $opFilter
    }
}
----

上述代码是最简单的角色管理，由于没有任何自定义逻辑，所以此处可直接使用 `Ex.form(reference)` 的方式实现相关提交，而配置使用了标准化按钮配置：

[options="header",cols="2,8"]
|====
|按钮ID|含义
|`$opAdd`|添加按钮专用表单函数，`mode=ADD`
|`$opSave`|更新按钮专用表单函数，`mode=EDIT`
|`$opDelete`|删除按钮专用表单函数。
|`$opFilter`|查询表单专用函数，右侧抽屉搜索框专用。
|====

最后需要注意的一点是此处的函数本身具有一定的基本规范

1. 此处的函数定义的是一个 **二阶函数**，函数签名如下
+
--
[source,js]
----
const $opXxx = (reference) => (params) => {

}
----

- `reference` 是和操作绑定的外层组件的引用，需要开发人员注意引入外层组件之后的层级关系，可通过 `Ux.onReference` 的方式精确捕捉所需组件。
- `params` 是 Ant Design 中的表单提交之后的数据。
--

2. 此处的操作函数返回一个 `Promise`，返回 `Proimse` 的原因很简单：**同步/异步** 统一，而且往往这种类型的提交都会和后端互动，所以使用 **异步** 比同步的实用性更强。
3. `Ex.form` 的表单对象引入了默认的 **防重复提交、默认回调、异常验证、异常回调、规则转换** 等综合性功能，除非您十分了解，否则只能自己老老实实书写自己的函数，如（自定义流程）：
+
--
[source,js]
----
const $opCreate = (reference) => (params) => {
    const request = Fn.ioRequest(params);
    let category = {};
    if (request.grouped) {
        category = Ux.elementUniqueDatum(reference, "preorder.category", "code", "Company");
    } else {
        category = Ux.elementUniqueDatum(reference, "preorder.category", "code", "Personal");
    }
    if (category) {
        request.category = category.key;
    }
    return Ux.ajaxPost("/api/order/standard/submit", request)
        .then(data => Ux.ajaxDialog(reference, {
            data, key: "submitted", redux: true,
        }))
        .then(response => Ux.formReset(reference, [], response));
};
----
由于此处没有使用 `Ex.form` 的表单对象，所以回调中的 `Ux.ajaxDialog` 以及执行完成之后的表单重置 `Ux.formReset` 都是必须的。
--

按照本章的教程，基本开发人员只需要 **拷贝** 骨架代码，然后书写对应的行为函数（ `Function` ）就可以完成表单部分的开发，且不需要书写太多的表单规则或逻辑规则，接下来看看表单中常用的 **字段配置**。